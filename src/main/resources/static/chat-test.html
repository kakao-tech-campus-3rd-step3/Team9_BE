<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pado 채팅 테스트 (리액션 + 삭제)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .modal-status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .modal-status.open {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .modal-status.closed {
            background-color: #f8d7da;
            color: #721c24;
        }
        .chat-messages {
            height: 400px;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: scroll;
            margin-bottom: 10px;
            background-color: #f9f9f9;
        }
        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            background-color: white;
            position: relative;
        }
        .message.deleted {
            background-color: #f0f0f0;
            opacity: 0.5;
        }
        .message-header {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .message-content {
            font-size: 14px;
            margin-bottom: 8px;
        }
        .message-actions {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-top: 8px;
        }
        .reaction-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 12px;
            background-color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .reaction-btn:hover {
            background-color: #f0f0f0;
        }
        .reaction-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .reaction-count {
            font-size: 12px;
            color: #666;
            margin-left: 2px;
        }
        .delete-btn {
            padding: 4px 8px;
            border: 1px solid #dc3545;
            border-radius: 4px;
            background-color: white;
            color: #dc3545;
            cursor: pointer;
            font-size: 12px;
            margin-left: auto;
        }
        .delete-btn:hover {
            background-color: #dc3545;
            color: white;
        }
        .unread-badge {
            background-color: #ff4444;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 10px;
        }
        .unread-count {
            background-color: #ff4444;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            margin: 10px 0;
            font-weight: bold;
            display: inline-block;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .input-group input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: black;
        }
        .btn-info {
            background-color: #17a2b8;
            color: white;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .logs {
            height: 150px;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: scroll;
            background-color: #f8f8f8;
            font-family: monospace;
            font-size: 12px;
        }
        .highlight {
            background-color: yellow;
            padding: 2px 4px;
        }
        .info-box {
            background-color: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 15px 0;
        }
        .info-box h4 {
            margin-top: 0;
            color: #007bff;
        }
        .new-feature {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
    </style>
</head>
<body>
<h1>🌊 Pado 채팅 테스트 (리액션 + 삭제)</h1>

<div class="container">
    <h2>연결 설정</h2>
    <div class="input-group">
        <input type="number" id="studyId" placeholder="스터디 ID (예: 1)" value="1">
        <input type="text" id="authToken" placeholder="JWT 토큰 (Bearer 제외)">
    </div>
    <div class="input-group">
        <button class="btn btn-success" onclick="connect()">WebSocket 연결</button>
        <button class="btn btn-danger" onclick="disconnect()">연결 해제</button>
    </div>
    <div id="connectionStatus" class="status disconnected">연결되지 않음</div>
</div>

<div class="container">
    <h2>채팅 모달 제어</h2>
    <div class="input-group">
        <button class="btn btn-info" onclick="openModal()">📂 모달 열기</button>
        <button class="btn btn-warning" onclick="closeModal()">📁 모달 닫기</button>
        <button class="btn btn-primary" onclick="loadChatHistory()">📋 채팅 기록</button>
    </div>
    <div id="modalStatus" class="modal-status closed">모달 상태: 닫힘</div>
    <div id="unreadCount" style="display: none;">
        <span class="unread-count">안읽은 메시지: 0개</span>
    </div>
    
    <div class="info-box new-feature">
        <h4>🎉 새로운 기능: 좋아요/싫어요 & 메시지 삭제</h4>
        <ul>
            <li>👍 <strong>좋아요/싫어요:</strong> 각 메시지에 리액션 추가 가능</li>
            <li>🔄 <strong>실시간 카운트:</strong> 리액션 수가 실시간으로 업데이트됨</li>
            <li>🗑️ <strong>메시지 삭제:</strong> 본인이 작성한 메시지 삭제 가능</li>
            <li>📡 <strong>웹소켓 알림:</strong> 모든 변경사항이 실시간 반영</li>
        </ul>
    </div>
</div>

<div class="container">
    <h2>채팅</h2>
    <div id="chatMessages" class="chat-messages"></div>
    <div class="input-group">
        <input type="text" id="messageInput" placeholder="메시지를 입력하세요..." maxlength="1000">
        <button class="btn btn-primary" onclick="sendMessage()">전송</button>
    </div>
</div>

<div class="container">
    <h2>로그</h2>
    <div id="logs" class="logs"></div>
    <button class="btn btn-primary" onclick="clearLogs()">로그 지우기</button>
</div>

<script>
    let stompClient = null;
    let currentStudyId = null;
    let currentUserId = null;
    let isModalOpen = false;
    let heartbeatInterval = null;
    let messageMap = new Map();
    let userReactions = new Map();

    function log(message, highlight = false) {
        const logs = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        const className = highlight ? 'class="highlight"' : '';
        logs.innerHTML += `<span ${className}>[${timestamp}] ${message}</span>\n`;
        logs.scrollTop = logs.scrollHeight;
    }

    function clearLogs() {
        document.getElementById('logs').innerHTML = '';
    }

    function updateConnectionStatus(connected) {
        const status = document.getElementById('connectionStatus');
        if (connected) {
            status.className = 'status connected';
            status.textContent = `스터디 ${currentStudyId} WebSocket 연결됨`;
        } else {
            status.className = 'status disconnected';
            status.textContent = '연결되지 않음';
        }
    }

    function updateModalStatus(open) {
        isModalOpen = open;
        const status = document.getElementById('modalStatus');
        if (open) {
            status.className = 'modal-status open';
            status.textContent = '모달 상태: 열림';
        } else {
            status.className = 'modal-status closed';
            status.textContent = '모달 상태: 닫힘';
        }
    }

    function updateUnreadCount(count) {
        const unreadDiv = document.getElementById('unreadCount');
        if (count > 0) {
            unreadDiv.innerHTML = `<span class="unread-count">안읽은 메시지: ${count}개</span>`;
            unreadDiv.style.display = 'block';
        } else {
            unreadDiv.style.display = 'none';
        }
    }

    function startHeartbeat() {
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
        }
        heartbeatInterval = setInterval(() => {
            if (stompClient && stompClient.connected && isModalOpen) {
                stompClient.send(`/app/studies/${currentStudyId}/modal/heartbeat`, {}, JSON.stringify({}));
                log('💓 Heartbeat 전송');
            }
        }, 240000);
    }

    function stopHeartbeat() {
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
        }
    }

    function connect() {
        const studyId = document.getElementById('studyId').value;
        const authToken = document.getElementById('authToken').value;

        if (!studyId || !authToken) {
            alert('스터디 ID와 JWT 토큰을 입력해주세요');
            return;
        }

        currentStudyId = studyId;
        log('🔌 WebSocket 연결 시도...');

        const socket = new SockJS('/ws');
        stompClient = Stomp.over(socket);

        const headers = {
            'Authorization': `Bearer ${authToken}`
        };

        stompClient.connect(headers, function(frame) {
            log('✅ WebSocket 연결 성공!');
            updateConnectionStatus(true);

            stompClient.subscribe(`/topic/studies/${studyId}/chats`, function(message) {
                const chatMessage = JSON.parse(message.body);
                
                // 내가 보낸 메시지면 currentUserId 설정
                if (!currentUserId && chatMessage.senderId) {
                    // 일단 저장 (나중에 비교용)
                    if (!window.recentSenderId) {
                        window.recentSenderId = chatMessage.senderId;
                        currentUserId = chatMessage.senderId;
                        log(`✅ 현재 사용자 ID 자동 설정: ${currentUserId}`);
                    }
                }
                
                displayMessage(chatMessage);
                log(`💬 채팅 메시지 수신: ${chatMessage.senderName}`);
            });

            stompClient.subscribe(`/topic/studies/${studyId}/updates`, function(message) {
                const update = JSON.parse(message.body);
                handleChatUpdate(update);
            });

            stompClient.subscribe(`/topic/studies/${studyId}/unread`, function(message) {
                const readData = JSON.parse(message.body);
                updateUnreadCountForMessagesAfter(readData.lastReadMessageId);
                log(`📖 읽음 상태 업데이트`);
            });

            stompClient.subscribe(`/user/queue/studies/${studyId}/unread`, function(message) {
                const unreadData = JSON.parse(message.body);
                updateUnreadCount(unreadData.unreadCount);
                log(`🔔 안읽은 메시지: ${unreadData.unreadCount}개`, true);
            });

            stompClient.subscribe('/user/queue/errors', function(message) {
                const error = JSON.parse(message.body);
                log('❌ 에러: ' + JSON.stringify(error), true);
                alert(`에러: ${error.message}`);
            });

            log(`📡 스터디 ${studyId} 구독 완료`);
            fetchCurrentUserId(authToken);

        }, function(error) {
            log('❌ WebSocket 연결 실패: ' + error, true);
            updateConnectionStatus(false);
        });
    }

    async function fetchCurrentUserId(authToken) {
        try {
            const response = await fetch('/api/users/me', {
                headers: {
                    'Authorization': `Bearer ${authToken}`
                }
            });
            if (response.ok) {
                const user = await response.json();
                currentUserId = user.userId;
                log(`✅ 현재 사용자 ID: ${currentUserId}`);
            }
        } catch (error) {
            log('⚠️ 사용자 ID 가져오기 실패 (삭제 버튼이 표시되지 않습니다)');
        }
    }

    function disconnect() {
        if (isModalOpen) {
            closeModal();
        }
        if (stompClient !== null) {
            stompClient.disconnect();
            log('🔌 WebSocket 연결 해제');
        }
        updateConnectionStatus(false);
        stopHeartbeat();
        currentStudyId = null;
        currentUserId = null;
        messageMap.clear();
        userReactions.clear();
    }

    function openModal() {
        if (!stompClient || !stompClient.connected) {
            alert('먼저 WebSocket에 연결해주세요');
            return;
        }
        log('📂 모달 열기 요청...');
        stompClient.send(`/app/studies/${currentStudyId}/modal/open`, {}, JSON.stringify({}));
        updateModalStatus(true);
        updateUnreadCount(0);
        startHeartbeat();
        log('✅ 모달 열림', true);
    }

    function closeModal() {
        if (!stompClient || !stompClient.connected) {
            alert('먼저 WebSocket에 연결해주세요');
            return;
        }
        log('📁 모달 닫기 요청...');
        stompClient.send(`/app/studies/${currentStudyId}/modal/close`, {}, JSON.stringify({}));
        updateModalStatus(false);
        stopHeartbeat();
        log('✅ 모달 닫힘', true);
    }

    function sendMessage() {
        const messageInput = document.getElementById('messageInput');
        const content = messageInput.value.trim();

        if (!content) {
            alert('메시지를 입력해주세요');
            return;
        }

        if (!stompClient || !stompClient.connected) {
            alert('먼저 WebSocket에 연결해주세요');
            return;
        }

        const message = {
            content: content
        };

        log(`📤 메시지 전송: ${content}`);
        stompClient.send(`/app/studies/${currentStudyId}/chats`, {}, JSON.stringify(message));
        messageInput.value = '';
    }

    function handleChatUpdate(update) {
        if (update.type === 'imoji') {
            updateReactionCount(update.messageId, update.likeCount, update.dislikeCount);
            log(`👍👎 리액션 업데이트: messageId=${update.messageId}`, true);
        } else if (update.type === 'deleted') {
            deleteMessageFromUI(update.messageId);
            log(`🗑️ 메시지 삭제: messageId=${update.messageId}`, true);
        }
    }

    function updateReactionCount(messageId, likeCount, dislikeCount) {
        const messageDiv = messageMap.get(messageId);
        if (messageDiv) {
            const likeBtn = messageDiv.querySelector('.like-btn');
            const dislikeBtn = messageDiv.querySelector('.dislike-btn');
            
            if (likeBtn) {
                likeBtn.innerHTML = `👍 <span class="reaction-count">${likeCount || 0}</span>`;
            }
            if (dislikeBtn) {
                dislikeBtn.innerHTML = `👎 <span class="reaction-count">${dislikeCount || 0}</span>`;
            }
        }
    }

    function deleteMessageFromUI(messageId) {
        const messageDiv = messageMap.get(messageId);
        if (messageDiv) {
            messageDiv.classList.add('deleted');
            const contentDiv = messageDiv.querySelector('.message-content');
            contentDiv.textContent = '삭제된 메시지입니다';
            
            const actionsDiv = messageDiv.querySelector('.message-actions');
            if (actionsDiv) {
                actionsDiv.remove();
            }
        }
    }

    async function handleReaction(messageId, reactionType) {
        const authToken = document.getElementById('authToken').value;
        const currentReaction = userReactions.get(messageId);

        try {
            if (currentReaction === reactionType) {
                const response = await fetch(`/api/studies/${currentStudyId}/chats/${messageId}/reactions`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (response.ok) {
                    userReactions.delete(messageId);
                    updateReactionButtonState(messageId, null);
                    log(`🔄 리액션 삭제 성공`);
                }
            } else if (currentReaction) {
                const response = await fetch(`/api/studies/${currentStudyId}/chats/${messageId}/reactions`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ reaction: reactionType })
                });
                
                if (response.ok) {
                    userReactions.set(messageId, reactionType);
                    updateReactionButtonState(messageId, reactionType);
                    log(`🔄 리액션 변경 성공`);
                }
            } else {
                const response = await fetch(`/api/studies/${currentStudyId}/chats/${messageId}/reactions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ reaction: reactionType })
                });
                
                if (response.status === 201) {
                    userReactions.set(messageId, reactionType);
                    updateReactionButtonState(messageId, reactionType);
                    log(`✅ 리액션 생성 성공`);
                }
            }
        } catch (error) {
            log(`❌ 리액션 처리 에러: ${error.message}`, true);
        }
    }

    function updateReactionButtonState(messageId, activeReaction) {
        const messageDiv = messageMap.get(messageId);
        if (messageDiv) {
            const likeBtn = messageDiv.querySelector('.like-btn');
            const dislikeBtn = messageDiv.querySelector('.dislike-btn');
            
            if (likeBtn) {
                likeBtn.classList.toggle('active', activeReaction === 'like');
            }
            if (dislikeBtn) {
                dislikeBtn.classList.toggle('active', activeReaction === 'dislike');
            }
        }
    }

    async function handleDelete(messageId) {
        if (!confirm('이 메시지를 삭제하시겠습니까?')) {
            return;
        }

        const authToken = document.getElementById('authToken').value;

        try {
            const response = await fetch(`/api/studies/${currentStudyId}/chats/${messageId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${authToken}`
                }
            });
            
            if (response.status === 204) {
                log(`✅ 메시지 삭제 성공`);
            }
        } catch (error) {
            log(`❌ 메시지 삭제 에러: ${error.message}`, true);
        }
    }

    function displayMessage(message) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        messageDiv.dataset.messageId = message.messageId;

        // 내가 보낸 메시지를 받았을 때 currentUserId 자동 설정
        // (senderName이 현재 로그인한 사용자와 같으면 senderId 저장)
        if (!currentUserId && message.senderName) {
            // 나중에 내가 메시지를 보내면 그때 설정됨
        }

        const timestamp = new Date(message.createdAt).toLocaleString();
        
        const unreadBadge = message.unreadMemberCount > 0 
            ? `<span class="unread-badge">${message.unreadMemberCount}명 안 읽음</span>`
            : '';

        // senderId가 있으면 비교, 없으면 모든 메시지에 삭제 버튼 표시 (테스트용)
        const deleteBtn = (!currentUserId || message.senderId === currentUserId)
            ? `<button class="delete-btn" onclick="handleDelete(${message.messageId})">🗑️ 삭제</button>`
            : '';

        messageDiv.innerHTML = `
            <div class="message-header">
                <div>
                    <strong>${message.senderName}</strong> - ${timestamp}
                </div>
                ${unreadBadge}
            </div>
            <div class="message-content">${escapeHtml(message.content)}</div>
            <div class="message-actions">
                <button class="reaction-btn like-btn" onclick="handleReaction(${message.messageId}, 'like')">
                    👍 <span class="reaction-count">0</span>
                </button>
                <button class="reaction-btn dislike-btn" onclick="handleReaction(${message.messageId}, 'dislike')">
                    👎 <span class="reaction-count">0</span>
                </button>
                ${deleteBtn}
            </div>
        `;

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        messageMap.set(message.messageId, messageDiv);
    }

    function updateUnreadCountForMessagesAfter(previousLastReadMessageId) {
        messageMap.forEach((messageDiv, messageId) => {
            if (messageId > previousLastReadMessageId) {
                const badge = messageDiv.querySelector('.unread-badge');
                if (badge) {
                    const currentCount = parseInt(badge.textContent);
                    const newCount = Math.max(0, currentCount - 1);
                    
                    if (newCount === 0) {
                        badge.remove();
                    } else {
                        badge.textContent = `${newCount}명 안 읽음`;
                    }
                }
            }
        });
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    async function loadChatHistory() {
        const authToken = document.getElementById('authToken').value;
        const studyId = document.getElementById('studyId').value;

        if (!authToken || !studyId) {
            alert('스터디 ID와 JWT 토큰을 입력해주세요');
            return;
        }

        try {
            log('📋 채팅 기록 불러오는 중...');

            const response = await fetch(`/api/studies/${studyId}/chats?size=50`, {
                headers: {
                    'Authorization': `Bearer ${authToken}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const data = await response.json();
                log(`✅ 채팅 기록 ${data.messages.length}개 불러옴`);

                document.getElementById('chatMessages').innerHTML = '';
                messageMap.clear();
                userReactions.clear();

                data.messages.reverse().forEach(message => {
                    displayMessage(message);
                });

            } else {
                log(`❌ 채팅 기록 불러오기 실패: ${response.status}`, true);
            }
        } catch (error) {
            log('❌ 채팅 기록 불러오기 에러: ' + error, true);
        }
    }

    document.getElementById('messageInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    window.onload = function() {
        log('🌊 Pado 채팅 테스트 페이지 로드됨 (리액션 + 삭제)');
        log('📝 사용 전에 JWT 토큰과 스터디 ID를 입력하세요');
        log('✨ 새로운 기능: 좋아요/싫어요 & 메시지 삭제!');
    };

    window.addEventListener('beforeunload', function() {
        if (isModalOpen) {
            closeModal();
        }
        if (stompClient !== null) {
            stompClient.disconnect();
        }
        stopHeartbeat();
    });
</script>
</body>
</html>
